<!doctype html>
<html lang="en">
  <head>
  
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    
  
    <title>CSS Extend Rule</title>
    
  
    <style>
@media print {
  html { margin: 0 !important; }
  body { font-family: serif; }
  th, td { font-family: inherit; }
  a { color: inherit !important; }
  .example:before { font-family: serif !important; }
  a:link, a:visited { text-decoration: none !important; }
  a:link:after, a:visited:after { /* create a cross-ref "see..." */; }
}
@page {
  margin: 1.5cm 1.1cm;
}
h1, h2, h3, h4, h5, h6 { page-break-after: avoid; }
figure, div.figure, div.sidefigure, pre, table.propdef, table.propdef-extra,
.example { page-break-inside: avoid; }
dt { page-break-after: avoid; }

body {
  background: white;
  /* background-image: floating-margin-image-goes-here; */
  background-position: top left;
  background-attachment: fixed;
  background-repeat: no-repeat;
  color: black;
  counter-reset: exampleno figure issue;
  font-family: sans-serif;
  line-height: 1.5;
  margin: 0 auto;
  max-width: 50em;
  padding: 2em 1em 2em 70px;
}

/* General structural markup */

h1, h2, h3, h4, h5, h6 { text-align: left; }
h1, h2, h3 { color: #005A9C; }
h1 { font: 170% sans-serif; }
h2 { font: 140% sans-serif; }
h3 { font: 120% sans-serif; }
h4 { font: bold 100% sans-serif; }
h5 { font: italic 100% sans-serif; }
h6 { font: small-caps 100% sans-serif; }
h2, h3, h4, h5, h6 { margin-top: 3em; }
h1 + h2 { margin-top: 0em; }
h2 + h3, h3 + h4, h4 + h5, h5 + h6 { margin-top: 1.2em; }

.head { margin-bottom: 1em; }
.head h1 { margin-top: 2em; clear: both; }
.head table { margin-left: 2em; margin-top: 2em; }
.head dd { margin-bottom: 0; }

p.copyright { font-size: small; }
p.copyright small { font-size: small; }

pre { margin: 1em 0 1em 2em; overflow: auto; }
pre, code, .idl-code {
  font-size: .9em;
  font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
}
dt dfn code { font-size: inherit; }

dfn { font-weight: bolder; }
dfn var { font-style: normal; }

s, del {text-decoration: line-through; color: red; }
u, ins {text-decoration: underline; background: #bfa; }

sup {
  vertical-align: super;
  font-size: 80%
}

details { display: block; }

dt { font-weight: bold; }
dd { margin: 0 0 1em 2em; }
ul, ol { margin-left: 0; padding-left: 2em; }
li { margin: 0.25em 2em 0.5em 0; padding-left: 0; }
[data-md] > :first-child { margin-top: 0; }
[data-md] > :last-child { margin-bottom: 0; }

td.pre {
  white-space: pre-wrap;
}

.css, .property { color: #005a9c; }
.property { white-space: nowrap; }


/* Boilerplate sections */

ul.indexlist { margin-left: 0; columns: 13em; }
ul.indexlist li { margin-left: 0; list-style: none }
ul.indexlist li li { margin-left: 1em; }
ul.indexlist a { font-weight: bold; }
ul.indexlist ul, ul.indexlist dl { font-size: smaller; }
ul.indexlist dl { margin-top: 0; }
ul.indexlist dt { margin: .2em 0 .2em 20px; }
ul.indexlist dd { margin: .2em 0 .2em 40px; }

.toc {
  font-weight: bold;
  line-height: 1.3;
  list-style: none;
  margin: 1em 0 0 5em;
  padding: 0;
}
.toc ul { margin: 0; padding: 0; font-weight: normal; }
.toc ul ul { margin: 0 0 0 2em; font-style: italic; }
.toc ul ul ul { margin: 0}
.toc > li { margin: 1.5em 0; padding: 0; }
.toc li { clear: both; }
.toc ul.toc li { margin: 0.3em 0 0 0; }
.toc a { border-bottom-style: none; }
.toc a:hover, ul.toc a:focus { border-bottom-style: solid; }
/* Section numbers in a column of their own */
.toc span.secno {float: left; width: 4em; margin-left: -5em}
.toc ul ul span.secno { margin-left: -7em; }

table.proptable {
  font-size: small;
  border-collapse: collapse;
  border-spacing: 0;
  text-align: left;
  margin: 1em 0;
}
table.proptable td, table.proptable th {
  padding: 0.4em;
  text-align: center;
}
table.proptable tr:hover td { background: #DEF; }


/* Links */

a[href] { color: inherit; border-bottom: 1px solid silver; text-decoration: none; }
a[href]:hover { background: #ffa; }
a[href]:active { color: #C00; background: transparent; }
img, a.logo { border-style: none; }
.heading, .issue, .note, .example, li, dt { position: relative; }
/* CSS-ish link types */
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {content: "“";}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {content: "”";}
[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after { content: ""; }
/* Element-type link styling */
[data-link-type=element] { font-family: monospace; }
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after { content: ">" }
/* Self-links */
a.self-link {
  position: absolute;
  top: 0;
  left: -2.5em;
  width: 2em;
  height: 2em;
  text-align: center;
  border: none;
  transition: opacity .2s;
  opacity: .5;
}
a.self-link:hover {
  opacity: 1;
}
.heading > a.self-link {
  font-size: 83%;
}
li > a.self-link {
  left: -3.5em;
}
dfn > a.self-link {
  top: auto;
  left: auto;
  opacity: 0;
  width: 1.5em;
  height: 1.5em;
  background: gray;
  color: white;
  font-style: normal;
  transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
  opacity: 1;
}
dfn > a.self-link:hover {
  color: black;
}
a.self-link::before { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before { content: "#"; }


/* Figures */

figure {
  display: block;
  text-align: center;
  margin: 2.5em 0;
}
figure.sidefigure {
  float: right;
  width: 50%;
  margin: 0 0 0.5em 0.5em
}
figure pre {
  text-align: left;
  display: table;
  margin: 1em auto;
}
figure table {
  margin: auto;
}
figure img, figure object {
  display: block;
  margin: auto;
  max-width: 100%
}
figcaption {
  counter-increment: figure;
  font-size: 90%;
  font-style: italic;
  text-align: center;
}
figcaption::before {
  content: "Figure " counter(figure) ". ";
  font-weight: bold;
}
dd figure { margin-left: -2em; }


/* Definition tables */

table.definition {
  border-spacing: 0;
  padding: 0 1em 0.5em;
  width: 100%;
  table-layout: fixed;
  margin: 1.2em 0;
}
table.definition td, table.definition th {
  padding: 0.5em;
  vertical-align: baseline;
  border-bottom: 1px solid #bbd7e9;
}
table.definition th:first-child {
  font-style: italic;
  font-weight: normal;
  text-align: left;
  width: 8.3em;
  padding-left: 1em;
}
table.definition > tbody > tr:last-child > th,
table.definition > tbody > tr:last-child > td {
  border-bottom: none;
}
table.definition tr:first-child > th,
table.definition tr:first-child > td {
  padding-top: 1em;
}
/* Footnotes at the bottom of a definition table */
table.definition td.footnote {
  font-style: normal;
  padding-top: .6em;
  width: auto;
}
table.definition td.footnote::before {
  content: " ";
  display: block;
  height: 0.6em;
  width: 4em;
  border-top: thin solid;
}


/* IDL fragments */

pre.idl {
  padding: .5em 1em;
  margin: 1.2em 0;
}
pre.idl :link, pre.idl :visited {
  color:inherit;
  background:transparent;
}


/* Data tables */
/* Comes in plain, long, complex, or define varieties */

.data {
  margin: 1em auto;
  border-collapse: collapse;
  width: 100%;
  border: hidden;
}
.data {
  text-align: center;
  width: auto;
}
.data caption {
  width: 100%;
}
.data td, .data th {
  padding: 0.5em;
  border-width: 1px;
  border-color: silver;
  border-top-style: solid;
}
.data thead td:empty {
  padding: 0;
  border: 0;
}
.data thead th[scope="row"] {
  text-align: right;
  color: inherit;
}
.data thead,
.data tbody {
  color: inherit;
  border-bottom: 2px solid;
}
.data colgroup {
  border-left: 2px solid;
}
.data tbody th:first-child,
.data tbody td[scope="row"]:first-child {
  text-align: right;
  color: inherit;
  border-right: 2px solid;
  border-top: 1px solid silver;
  padding-right: 1em;
}
.data.define td:last-child {
  text-align: left;
}
.data tbody th[rowspan],
.data tbody td[rowspan] {
  border-left: 1px solid silver;
}
.data tbody th[rowspan]:first-child,
.data tbody td[rowspan]:first-child {
  border-left: 0;
  border-right: 1px solid silver;
}
.data.complex th,
.data.complex td {
  border: 1px solid silver;
}
.data td.long {
 vertical-align: baseline;
 text-align: left;
}
.data img {
  vertical-align: middle;
}


/* Switch/case <dl>s */

dl.switch {
 padding-left: 2em;
}
dl.switch > dt {
 text-indent: -1.5em;
}
dl.switch > dt:before {
 content: '↪';
 padding: 0 0.5em 0 0;
 display: inline-block;
 width: 1em;
 text-align: right;
 line-height: 0.5em;
}


/* Style for At Risk features (intended as editorial aid, not intended for publishing) */
.atrisk::before {
 position: absolute;
 margin-left: -5em;
 margin-top: -2px;
 padding: 4px;
 border: 1px solid;
 content: 'At risk';
 font-size: small;
 background-color: white;
 color: gray;
 border-radius: 1em;
 text-align: center;
}


/* Obsoletion notice */
details.annoying-warning[open] {
  background: #fdd;
  color: red;
  font-weight: bold;
  text-align: center;
  padding: .5em;
  border: thick solid red;
  border-radius: 1em;
  position: fixed;
  left: 1em;
  right: 1em;
  bottom: 1em;
  z-index: 1000;
}
details.annoying-warning:not([open]) > summary {
  background: #fdd;
  color: red;
  font-weight: bold;
  text-align: center;
  padding: .5em;
}


/* Examples */

.example {
  counter-increment: exampleno;
}
.example::before {
  content: "Example";
  content: "Example " counter(exampleno);
  min-width: 7.5em;
  text-transform: uppercase;
  display: block;
}
.illegal-example::before {
  content: "Invalid Example";
  content: "Invalid Example" counter(exampleno);
}
.example, .illegal-example, .html, .illegal-html, .xml, .illegal-xml {
  padding: 0.5em;
  margin: 1em 0;
  position: relative;
  clear: both;
}
pre.example, pre.illegal-example, pre.html,
pre.illegal-html, pre.xml, pre.illegal-xml {
  padding-top: 1.5em;
}
.illegal-example { color: red; }
.illegal-example p { color: black; }
.html { color: #600; }
.illegal-html { color: red; }
.illegal-html p { color: black; }
.xml { color: #600; }
.illegal-xml { color: red; }
.illegal-xml p { color: black; }
code.css { font-family: inherit; font-size: 100% }
code.html { color: #600 } /* inline HTML */
code.xml { color: #600 }  /* inline XML */


/* Issues */

.issue {
  border-color: #E05252;
  background: #FBE9E9;
  counter-increment: issue;
}
.issue:before {
  content: "Issue " counter(issue);
  padding-right: 1em;
  text-transform: uppercase;
  color: #E05252;
}


/* Whys */

details.why > summary {
  font-style: italic;
}
details.why[open] > summary {
  border-bottom: 1px silver solid;
}


/* All the blocks get similarly styled */

table.definition, pre.idl, .example, .note, details.why, .issue {
  border: none;
  border-left: .5em solid black;
  border-left: .5rem solid black;
}
.issue, .note, .example, .why {
  padding: .5em;
  margin-top: 1em;
  margin-bottom: 1em;
}
table.definition, pre.idl {
  background: hsl(210, 70%, 95%);
  border-color: hsl(210, 80%, 75%);
}
.example {
  background: hsl(50, 70%, 95%);
  border-color: hsl(50, 70%, 60%);
}
.example::before {
  color: hsl(50, 70%, 60%);
}
.note, details.why {
  background: hsl(120, 70%, 95%);
  border-color: hsl(120, 70%, 60%);
}
.note::before {
  color: hsl(120, 70%, 60%);
}
.issue {
  background: hsl(0, 70%, 95%);
  border-color: hsl(0, 70%, 60%);
}
.issue::before {
  color: hsl(0, 70%, 60%);
}
span.issue, span.note {
  padding: .1em .5em .15em;
  border-right-width: .5em;
  border-right-style: solid;
}
  </style>
    

    <script>self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;

var _ = self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					return o.slice();
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		// Insert a token before another token in a language literal
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];
			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type) {
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object') {
						_.languages.DFS(o[i], callback);
					} else if (_.util.type(o[i]) === 'Array') {
						_.languages.DFS(o[i], callback, i);
					}
				}
			}
		}
	},

	highlightAll: function(async, callback) {
		var elements = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');
		for (var i=0, element; element = elements[i++];) {
			if (element.classList.contains("idl")) {
				// Bikeshed handles IDL blocks already.
				continue;
			}
			_.highlightElement(element, async === true, callback);
		}

		var elements = document.querySelectorAll('pre[class*="language-"], [class*="language-"] pre, pre[class*="lang-"], [class*="lang-"] pre');
		for (var i=0, element; element = elements[i++];) {
			if (element.firstElementChild && element.firstElementChild.tagName.toLowerCase() == "code") {
				// Already handled by the previous loop
				continue;
			}
			if (element.classList.contains("idl")) {
				// Bikeshed handles IDL blocks already.
				continue;
			}
			_.highlightElement(element, async === true, callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1];
			grammar = _.languages[language];
		}

		if (!grammar) {
			return;
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		if(!code) {
			return;
		}

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-highlight', env);

		if (async && self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language)

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					lookbehindLength = 0,
					alias = pattern.alias;

				pattern = pattern.pattern || pattern;

				for (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str);

					if (match) {
						if(lookbehind) {
							lookbehindLength = match[1].length;
						}

						var from = match.index - 1 + lookbehindLength,
							match = match[0].slice(lookbehindLength),
							len = match.length,
							to = from + len,
							before = str.slice(0, from + 1),
							after = str.slice(to + 1);

						var args = [i, 1];

						if (before) {
							args.push(before);
						}

						var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias);

						args.push(wrapped);

						if (after) {
							args.push(after);
						}

						Array.prototype.splice.apply(strarr, args);
					}
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias) {
	this.type = type;
	this.content = content;
	this.alias = alias;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (Object.prototype.toString.call(o) == '[object Array]') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = '';

	for (var name in env.attributes) {
		attributes += name + '="' + (env.attributes[name] || '') + '"';
	}

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '" ' + attributes + '>' + env.content + '</' + env.tag + '>';

};

if (!self.document) {
	if (!self.addEventListener) {
		// in Node.js
		return self.Prism;
	}
 	// In worker
	self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code;

		self.postMessage(JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang]))));
		self.close();
	}, false);

	return self.Prism;
}

// Get current script and highlight
var script = document.getElementsByTagName('script');

script = script[script.length - 1];

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		document.addEventListener('DOMContentLoaded', _.highlightAll);
	}
}

return self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}
;
Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//g,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*{))/gi,
		inside: {
			'punctuation': /[;:]/g
		}
	},
	'url': /url\((["']?).*?\1\)/gi,
	'selector': /[^\{\}\s][^\{\};]*(?=\s*\{)/g,
	'property': /(\b|\B)[\w-]+(?=\s*:)/ig,
	'string': /("|')(\\?.)*?\1/g,
	'important': /\B!important\b/gi,
	'punctuation': /[\{\};:]/g,
	'function': /[-a-z0-9]+(?=\()/ig
};

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /<style[\w\W]*?>[\w\W]*?<\/style>/ig,
			inside: {
				'tag': {
					pattern: /<style[\w\W]*?>|<\/style>/ig,
					inside: Prism.languages.markup.tag.inside
				},
				rest: Prism.languages.css
			}
		}
	});
};
Prism.languages.css.selector = {
	pattern: /[^\{\}\s][^\{\}]*(?=\s*\{)/g,
	inside: {
		'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/g,
		'pseudo-class': /:[-\w]+(?:\(.*\))?/g,
		'class': /\.[-:\.\w]+/g,
		'id': /#[-:\.\w]+/g
	}
};

Prism.languages.insertBefore('css', 'ignore', {
	'hexcode': /#[\da-f]{3,6}/gi,
	'entity': /\\[\da-f]{1,8}/gi,
	'number': /[\d%\.]+/g
});;
</script>
    <style>/* http://prismjs.com/download.html?themes=prism&languages=clike */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important {
	font-weight: bold;
}

.token.entity {
	cursor: help;
}
</style>
  </head>
  

  <body class="h-entry">

    <div class="head">
  
      <p data-fill-with="logo"></p>
  
      <h1 class="p-name no-ref" id="title">CSS Extend Rule</h1>
  
      <h2 class="no-num no-toc no-ref heading settled" id="subtitle"><span class="content">A Collection of Interesting Ideas,
    <time class="dt-updated" datetime="2015-01-15">15 January 2015</time></span></h2>
  
      <div data-fill-with="spec-metadata">
        <dl>
          <dt>This version:</dt>
          <dd><a class="u-url" href="tabatkins.github.io/specs/css-extend-rule/">tabatkins.github.io/specs/css-extend-rule/</a></dd>
          <dt>Issue Tracking:</dt>
          <dd><a href="#issues-index">Inline In Spec</a></dd>
          <dt class="editor">Editor:</dt>
          <dd class="editor">
            <div class="p-author h-card vcard"><a class="p-name fn u-url url" href="http://xanthir.com">Tab Atkins</a> (<span class="p-org org">Google</span>)</div>
          </dd>
        </dl>
      </div>
  
      <div data-fill-with="warning"></div>
  
      <p class="copyright" data-fill-with="copyright"><a href="http://creativecommons.org/publicdomain/zero/1.0/" rel="license"><img alt="CC0" src="https://licensebuttons.net/p/zero/1.0/80x15.png"></a>
To the extent possible under law, the editors have waived all copyright
and related or neighboring rights to this work.
In addition, as of 15 January 2015,
the editors have made this specification available under the
<a href="http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0" rel="license">Open Web Foundation Agreement Version 1.0</a>,
which is available at http://www.openwebfoundation.org/legal/the-owf-1-0-agreements/owfa-1-0.
Parts of this work may be from another specification document.  If so, those parts are instead covered by the license of that specification document.
</p>
  
      <hr title="Separator for header">
</div>


    <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>

    <div class="p-summary" data-fill-with="abstract">
      <p>This module defines the <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule, which allows elements to act as if they matched other selectors.

This makes it easier to "subclass" styling in a page,
when some new type of element should act like an existing element,
but with tweaks.</p>

</div>

    <div data-fill-with="at-risk"></div>


    <h2 class="no-num no-toc no-ref heading settled" id="contents"><span class="content">Table of Contents</span></h2>

    <div data-fill-with="table-of-contents" role="navigation">
      <ul class="toc" role="directory">
        <li><a href="#intro"><span class="secno">1</span> <span class="content">Introduction</span></a></li>
        <li><a href="#extend-rule"><span class="secno">2</span> <span class="content">The <span class="css" data-link-type="maybe" title="@extend">@extend</span> Rule</span></a>
          <ul class="toc">
            <li><a href="#extend-chaining"><span class="secno">2.1</span> <span class="content"><span class="css" data-link-type="maybe" title="@extend">@extend</span> Chaining</span></a></li>
          </ul>
        </li>
        <li><a href="#placeholder"><span class="secno">3</span> <span class="content">The Placeholder Selector <span class="css">%foo</span></span></a></li>
        <li><a href="#acks"><span class="secno">4</span> <span class="content">Acknowledgements</span></a></li>
        <li><a href="#conformance"><span class="secno"></span> <span class="content">
Conformance</span></a></li>
        <li><a href="#references"><span class="secno"></span> <span class="content">References</span></a>
          <ul class="toc">
            <li><a href="#normative"><span class="secno"></span> <span class="content">Normative References</span></a></li>
          </ul>
        </li>
        <li><a href="#index"><span class="secno"></span> <span class="content">Index</span></a></li>
        <li><a href="#issues-index"><span class="secno"></span> <span class="content">Issues Index</span></a></li>
      </ul></div>

    <main>





      <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Introduction</span><a class="self-link" href="#intro"></a></h2>


      <p>Sometimes, when designing a page,
an author might create some styles for a given type of element,
such as "error" messages.
Later, they might realize they need to create a "subclass" of the first type,
such as a "serious error" message,
which is styled the same way as "error",
but with a few tweaks to make it more distinctive.
Currently, CSS does not have a good way to handle this.</p>


      <p>If the author has control over the HTML,
they can declare that every element with a class of "serious-error"
must also have a class of "error".
This, however, is error-prone--
it’s easy to forget to add the "error" class to an element,
causing confusing styling issues,
and any scripting that creates or manipulates error elements
has to know to maintain the states properly
(for example, any time they remove the "error" class,
	they have to remember to check for and remove "serious-error" as well).</p>


      <p>Alternately, this can be handled in the CSS--
every time a style rule contains a <span class="css">.error</span> selector,
the selector can be duplicated with <span class="css">.serious-error</span> replacing it.
This, too, is error-prone:
it’s easy for typos or inattention to cause the duplicated selectors to drift apart,
and it’s easy, when adding new <span class="css">.error</span> rules,
to forget to duplicate the selector.</p>


      <p>The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule, defined in this specification,
fixes this common issue.
It allows an author to declare that certain elements,
such as everything matching <span class="css">.serious-error</span>,
must <em>act as if</em> they had the necessary features to match another selector,
such as <span class="css">.error</span>.</p>


      <div class="example">
	For example, the following code declares that <span class="css">.serious-error</span> elements should act as if they were <span class="css">.error</span> elements as well:

	
        <pre class="lang-css">.error {
  color: red;
  border: thick dotted red;
}

.serious-error {
  @extend .error;
  font-weight: bold;
}
</pre>


        <p>Now an element like <code>&lt;div class=serious-error></code> will had red text and border,
	just like elements with <code>class=error</code>,
	but will also use bold text.</p>
</div>


      <p>This allows authors to write simple HTML,
applying either <code>class=error</code> or <code>class=serious-error</code> to elements as appropriate,
and write simple CSS,
creating style rules that just mention <span class="css">.error</span> or <span class="css">.serious-error</span>,
secure in the knowledge that the former rules will also apply to serious errors.</p>


      <h2 class="heading settled" data-level="2" id="extend-rule"><span class="secno">2. </span><span class="content">The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> Rule</span><a class="self-link" href="#extend-rule"></a></h2>


      <p>The <dfn class="css" data-dfn-type="at-rule" data-export="" id="at-ruledef-extend">@extend<a class="self-link" href="#at-ruledef-extend"></a></dfn> rule declares
that a matched element must act as if it had the necessary qualities to match another specified selector.
Its syntax is:</p>


      <pre class="prod">@extend <a class="production" data-link-type="type" href="http://dev.w3.org/csswg/selectors-4/#typedef-compound-selector">&lt;compound-selector></a>;</pre>


      <p>The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule is only allowed inside of style rules.
In any other context, an <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule is invalid.
An <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule modifies the way that selector matching works
for the elements matched by the style rule the <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> selector is inside of,
known as the <dfn data-dfn-type="dfn" data-noexport="" id="extended-elements">extended elements<a class="self-link" href="#extended-elements"></a></dfn> for that rule.</p>


      <p>The argument to <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> is the <dfn data-dfn-type="dfn" data-noexport="" id="extension-selector">extension selector<a class="self-link" href="#extension-selector"></a></dfn>.
The rule’s <a data-link-type="dfn" href="#extended-elements">extended elements</a> must,
for the purpose of determining if selectors match them,
act as if they had the necessary <a data-link-type="dfn" href="http://dev.w3.org/csswg/selectors-4/#feature">features</a>/state/etc to match the <a data-link-type="dfn" href="#extension-selector">extension selector</a>,
in addition to their pre-existing <a data-link-type="dfn" href="http://dev.w3.org/csswg/selectors-4/#feature">features</a>/state/etc.</p>


      <div class="example">
	For example, in the following code:

	
        <pre class="lang-css">.serious-error {
  @extend .error;
}
</pre>


        <p>All elements matching the <span class="css">.serious-error</span> selector
	must act as if they also had an "error" class
	for the purpose of matching selectors,
	regardless of what their actual set of classes is.</p>
</div>


      <p class="issue" id="issue-bd856557"><a class="self-link" href="#issue-bd856557"></a>Should this only affect selectors in CSS,
or should it affect all APIs using selectors?
Dunno which is saner for browsers;
probably all selector-based APIs.
Do other query APIs, like <code class="idl"><a data-link-type="idl">getElementsByTagName()</a></code>,
rely on the same machinery?
If so, should we generalize this to allow host languages to declare arbitrary querying APIs to be "selector-ish"?</p>


      <p>The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule only affects the <a data-link-type="dfn" href="#extended-elements">extended elements</a>
as long as the rule it’s inside of matches them.</p>


      <div class="example">
	For example, if the rule containing <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> is in an <a class="css" data-link-type="maybe" href="http://dev.w3.org/csswg/css-conditional-3/#at-ruledef-media">@media</a> block:

	
        <pre class="lang-css">.error {
  color: red;
}

@media (width > 600px) {
  .serious-error {
    @extend .error;
    font-weight: bold;
  }

  .error {
    width: 100%;
  }
}
</pre>


        <p>Then the <span class="css">.serious-error</span> elements only act as if they have an <code>error</code> class
	when the page’s width is greater than <span class="css">600px</span>.</p>
</div>


      <div class="example">
	Note that the <a data-link-type="dfn" href="#extension-selector">extension selector</a> can specify more than classes.
	For example, in the following code:

	
        <pre class="lang-css">.my-button {
  @extend button;
}
</pre>


        <p>Any elements with <code>class=my-button</code> receive the same styling as actual <a data-link-type="element" href="https://html.spec.whatwg.org/#the-button-element">button</a> elements,
	as if they had a tagname of <span class="css">button</span> in addition to their normal tagname.</p>


        <p>Similarly, in the following code:</p>

	
        <pre class="lang-css">.perma-pressed-button {
  @extend .button:active;
}
</pre>


        <p>Any <span class="css">.perma-pressed</span> elements are styled as if they were <a class="css" data-link-type="maybe" href="http://dev.w3.org/csswg/selectors-4/#active-pseudo">:active</a>,
	so that any styling applied to "pressed" buttons via <a class="css" data-link-type="maybe" href="http://dev.w3.org/csswg/selectors-4/#active-pseudo">:active</a> rules applies to them as well.</p>
</div>


      <div class="example">
	The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule effectively adds qualities to an element,
	so that it matches other rules.
	The selector used to apply the <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule has no effect on this.
	For example, in the following code:

	
        <pre class="lang-css">.red-text { color: red; }
.blue-text { color: blue; }

#sidebar { @extend .red-text; }
div { @extend .blue-text; }
</pre>


        <p>A naive author looking at the code and wondering how a <code>&lt;div id=sidebar></code> element would be styled
	might assume that it gets red text,
	as an ID selector is used to <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> the <span class="css">.red-text</span> class,
	versus a much less specific tagname selector.
	However, this is wrong—<wbr>the element gets blue text,
	as the <span class="css">.red-text</span> and <span class="css">.blue-text</span> rules have equal specificity,
	and the <span class="css">.blue-text</span> rule appears later in the stylesheet.
	The specificity of the rules that caused the element to match <span class="css">.red-text</span> or <span class="css">.blue-text</span> are irrelevant here.</p>


        <p>While this may in some cases be confusing,
	it can also be a great benefit in some cases.
	For example,
	an author can define a lot of styles with simple, one-class (or one <a data-link-type="dfn" href="#placeholder-selector">placeholder selector</a>) rules,
	effectively ignoring specificity entirely,
	then apply them via longer, much more specific selectors,
	using <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> to invoke the behavior of the simpler rules.
	This can allow an author to avoid many of the specificity problems of using IDs in rules, for example.</p>
</div>


      <h3 class="heading settled" data-level="2.1" id="extend-chaining"><span class="secno">2.1. </span><span class="content"><a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> Chaining</span><a class="self-link" href="#extend-chaining"></a></h3>


      <p>Multiple <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rules can be "chained",
with one rule adding certain qualities to an element,
which cause another style rule containing an <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> to match.</p>


      <p class="note" role="note">Note: This falls out of the definition automatically.
It is called out separately for clarity,
not because it’s a separate feature that needs to be specifically defined.</p>


      <div class="example">
	For example,
	the following code using <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a>:

	
        <pre class="lang-css">.error {
  color: red;
}

.serious-error {
  @extend .error;
  font-weight: bold;
}

.super-serious-error {
  @extend .serious-error;
  animation: flashing 1s infinite;
}
</pre>


        <p>is equivalent to the following code without <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a>:</p>

	
        <pre class="lang-css">.error, .serious-error, .super-serious-error {
  color: red;
}

.serious-error, .super-serious-error {
  font-weight: bold;
}

.super-serious-error {
  animation: flashing 1s infinite;
}
</pre>
</div>



      <h2 class="heading settled" data-level="3" id="placeholder"><span class="secno">3. </span><span class="content">The Placeholder Selector <span class="css">%foo</span></span><a class="self-link" href="#placeholder"></a></h2>


      <p>The <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule originates in CSS preprocessors, such as SASS.
Experience with those tools shows that it’s often useful to define generic, "functional" sets of styles
that don’t apply to any elements directly,
then use <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> to give that behavior to <em>semantic</em> classnames
which are more meaningful within their project.</p>


      <div class="example">
	For example, the "media block" is a common functional sort of styling,
	originating from OOCSS,
	that describes a box with a picture on one side and text on the other.
	It might be used like the following:

	
        <pre class="lang-css">.media-block {
  overflow: auto;
}
.media-block > img {
  float: left;
}
...

.image-post {
  @extend .media-block;
  ... /* additional styles to tweak the display */
}
</pre>
</div>


      <p>However, this also carries the possibility of confusion.
In the above example, <span class="css">.media-block</span> is just used to give a name to the pattern,
so that other rules can <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> it.
It’s not meant to be used in a document--
there shouldn’t be any elements with <code>class=media-block</code>--
but this isn’t obvious from the code.
It’s easy for later maintainers of the file to accidentally use <span class="css">.media-block</span> directly on an element,
and modify it for their own uses
(after all, if they search the codebase, they’ll find no elements on the page using it!),
perhaps accidentally breaking elements using it in <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a>.</p>


      <p>To avoid situations like this,
and make it more clear that one is developing a "generic"/"functional"/"structural" set of styles,
the <dfn data-dfn-type="dfn" data-noexport="" id="placeholder-selector">placeholder selector<a class="self-link" href="#placeholder-selector"></a></dfn> can be used.
Its syntax is similar to a <a data-link-type="dfn" href="http://dev.w3.org/csswg/selectors-4/#class-selector">class selector</a>,
but is prefixed by a <span class="css">%</span> (U+0025 PERCENT SIGN)
rather than a period.</p>


      <div class="example">
	The previous example could be more clearly written using a <a data-link-type="dfn" href="#placeholder-selector">placeholder selector</a>:

	
        <pre class="lang-css">%media-block {
  overflow: auto;
}
%media-block > img {
  float: left;
}
...

.image-post {
  @extend %media-block;
}
</pre>
</div>


      <p>Host languages must not provide any way for an element to match a <a data-link-type="dfn" href="#placeholder-selector">placeholder selector</a>;
the only way for an element to match one is by using an <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> rule.
This ensures that no element will ever directly match the styles using one,
even by accident,
and it can’t be accidentally reused for an element directly.</p>


      <p><a data-link-type="dfn" href="#placeholder-selector">Placeholder selectors</a> have the same specificity as <a data-link-type="dfn" href="http://dev.w3.org/csswg/selectors-4/#class-selector">class selectors</a>.</p>


      <p class="issue" id="issue-9ec63da0"><a class="self-link" href="#issue-9ec63da0"></a>Or should they have slightly less, so concrete classes can reliably override?
This would mean putting a fourth number into the specificity 3-tuple.</p>


      <h2 class="heading settled" data-level="4" id="acks"><span class="secno">4. </span><span class="content">Acknowledgements</span><a class="self-link" href="#acks"></a></h2>


      <p>The editor would like to thank the following people:</p>


      <ul>
        <li data-md="">
          <p><a href="https://twitter.com/stubbornella">Nicole Sullivan</a> for <a href="http://www.stubbornella.org/content/2009/11/09/css-wish-list/">first coming up with the idea for @extend</a>.</p>
          

        </li>
        <li data-md="">
          <p><a href="https://twitter.com/chriseppstein">Chris Eppstein</a> and <a href="https://twitter.com/nex3">Natalie Weizenbaum</a>
for <a href="http://chriseppstein.github.io/blog/2009/10/12/css-class-inheritance/">developing and programming</a> the modern incarnation of <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> in Sass.</p>
          

        </li>
        <li data-md="">
          <p>The Sass community, for using <a class="css" data-link-type="maybe" href="#at-ruledef-extend">@extend</a> so extensively that its lack in CSS couldn’t be ignored.</p>
          

        </li></ul>
</main>

    <h2 class="no-ref no-num heading settled" id="conformance"><span class="content">
Conformance</span><a class="self-link" href="#conformance"></a></h2>

    
    <p>
        Conformance requirements are expressed with a combination of descriptive assertions and RFC 2119 terminology.
        The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL”
        in the normative parts of this document
        are to be interpreted as described in RFC 2119.
        However, for readability,
        these words do not appear in all uppercase letters in this specification.

    </p>
    <p>
        All of the text of this specification is normative
        except sections explicitly marked as non-normative, examples, and notes. <a data-biblio-type="normative" data-link-type="biblio" href="#biblio-rfc2119" title="RFC2119">[RFC2119]</a>

    </p>
    <p>
        Examples in this specification are introduced with the words “for example”
        or are set apart from the normative text with <code>class="example"</code>, like this:

    </p>
    <div class="example">
        This is an example of an informative example.
    </div>

    
    <p>
        Informative notes begin with the word “Note”
        and are set apart from the normative text with <code>class="note"</code>, like this:

    </p>
    <p class="note" role="note">
        Note, this is an informative note.



</p>
    <h2 class="no-num heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
    <h3 class="no-num heading settled" id="normative"><span class="content">Normative References</span><a class="self-link" href="#normative"></a></h3>
    <dl>
      <dt id="biblio-rfc2119" title="rfc2119"><a class="self-link" href="#biblio-rfc2119"></a>[rfc2119]</dt>
      <dd>S. Bradner. <a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a></dd>
    </dl>
    <h2 class="no-num heading settled" id="index"><span class="content">Index</span><a class="self-link" href="#index"></a></h2>
    <ul class="indexlist">
      <li>@extend, <a href="#at-ruledef-extend" title="section 2">2</a></li>
      <li>extended elements, <a href="#extended-elements" title="section 2">2</a></li>
      <li>extension selector, <a href="#extension-selector" title="section 2">2</a></li>
      <li>placeholder selector, <a href="#placeholder-selector" title="section 3">3</a></li>
    </ul>
    <h2 class="no-num heading settled" id="issues-index"><span class="content">Issues Index</span><a class="self-link" href="#issues-index"></a></h2>
    <div style="counter-reset:issue">
      <div class="issue">Should this only affect selectors in CSS,
or should it affect all APIs using selectors?
Dunno which is saner for browsers;
probably all selector-based APIs.
Do other query APIs, like <code class="idl"><a data-link-type="idl">getElementsByTagName()</a></code>,
rely on the same machinery?
If so, should we generalize this to allow host languages to declare arbitrary querying APIs to be "selector-ish"?<a href="#issue-bd856557"> ↵ </a></div>
      <div class="issue">Or should they have slightly less, so concrete classes can reliably override?
This would mean putting a fourth number into the specificity 3-tuple.<a href="#issue-9ec63da0"> ↵ </a></div>
    </div></body>
</html>